import { ExternalTokenizer } from "@lezer/lr";

// These will be generated by lezer-generator from the grammar file
// If you see errors here, run: npm run lezer:build first
import { Indent, Dedent } from "./tome-parser.terms.js";

// Track indentation levels
class IndentationTracker {
  constructor() {
    this.levels = [0]; // Start with base indentation of 0
  }

  currentLevel() {
    return this.levels[this.levels.length - 1];
  }

  push(level) {
    this.levels.push(level);
  }

  pop() {
    return this.levels.pop();
  }

  dedentCount(level) {
    let count = 0;
    while (this.levels.length > 1 && this.currentLevel() > level) {
      this.pop();
      count++;
    }
    return count;
  }
}

// Measure indentation at current position
function measureIndentation(input, pos) {
  let spaces = 0;
  while (pos < input.length) {
    const ch = input.charCodeAt(pos);
    if (ch === 32) {
      // space
      spaces++;
      pos++;
    } else if (ch === 9) {
      // tab (count as 4 spaces)
      spaces += 4;
      pos++;
    } else {
      break;
    }
  }
  return spaces;
}

// Check if line is blank or comment-only
function isBlankOrComment(input, pos) {
  while (pos < input.length) {
    const ch = input.charCodeAt(pos);
    if (ch === 32 || ch === 9) {
      // space or tab
      pos++;
    } else if (ch === 35) {
      // # comment
      return true;
    } else if (ch === 10 || ch === 13) {
      // newline
      return true;
    } else {
      return false;
    }
  }
  return true;
}

const indentTracker = new IndentationTracker();
let pendingDedents = 0;

// Indentation tokenizer
export const indentation = new ExternalTokenizer((input, stack) => {
  // Only trigger after newlines or at start
  const prev = input.peek(-1);
  if (prev !== 10 && prev !== 13 && prev !== -1) {
    return;
  }

  // If we have pending dedents, emit them first
  if (pendingDedents > 0) {
    pendingDedents--;
    input.acceptToken(Dedent);
    return;
  }

  let pos = input.pos;

  // Skip blank lines and comment lines
  while (pos < input.length && isBlankOrComment(input.chunk, pos - input.pos)) {
    while (pos < input.length) {
      const ch = input.charCodeAt(pos);
      if (ch === 10 || ch === 13) {
        pos++;
        break;
      }
      pos++;
    }
  }

  // At end of file, emit all remaining dedents
  if (pos >= input.length) {
    if (indentTracker.levels.length > 1) {
      indentTracker.pop();
      input.acceptToken(Dedent);
      return;
    }
    return;
  }

  // Measure indentation of next non-blank line
  const indentation = measureIndentation(input.chunk, pos - input.pos);
  const currentLevel = indentTracker.currentLevel();

  // Indent: indentation increased
  if (indentation > currentLevel) {
    indentTracker.push(indentation);
    input.acceptToken(Indent);
  }
  // Dedent: indentation decreased
  else if (indentation < currentLevel) {
    const count = indentTracker.dedentCount(indentation);
    if (count > 0) {
      // Emit first dedent now, queue the rest
      pendingDedents = count - 1;
      input.acceptToken(Dedent);
    }
  }
  // Same level: no indent/dedent tokens needed
});

// Reset tracker for new parse
export function resetIndentation() {
  indentTracker.levels = [0];
  pendingDedents = 0;
}
